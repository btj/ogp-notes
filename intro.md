# Introduction: Topic of the course

This text contains the course notes for the course "Object-oriented programming" at KU Leuven, Belgium.
Although the title does not make this explicit, the course actually introduces students to three related topics:
* Object-Oriented Programming (OOP): a programming model (or paradigm) that organizes software using concepts like objects, methods and classes and applies techniques like inheritance and encapsulation to achieve modularity and code reuse.
* The programming language Java: a widely used, high-level programming language that was originally developed by James Gosling at Sun Microsystems, first released in 1995.
  Its design contains several features intended to support object-oriented programming.
* Modular programming: a very general software engineering principle.
The latter, which we will explain further, is by far the most important topic.

Modular programming is the principal method by which software engineers manage the complexity of the task of building, maintaining, and evolving large software systems.
From a high level, modular programming means _decomposing_ software systems into a number of _modules_, which may be developed, understood, verified, and evolved independently from, and in parallel with, other modules.
By enabling this independent evolution, the principle allows building, maintaining and evolving software systems that are much larger and more complex than would otherwise be possible.
Additionally, it allows this development to be executed by separate development teams, working in different organizations with different (economic or other) interests.
Good specifications of module interfaces are widely recognized as essential in software engineering, especially for important, long-lived APIs between separately developed modules.

To make this independent development possible, modular programming requires a clear and _abstract_ _specification_ of the interface over which modules interact.
For example, modules may invoke procedures in other modules, construct values of data types defined by other modules, etc. and the specification defines which interactions must be supported by one module and may be relied upon by another.
More concretely, an interface will define the syntax and semantics of the program elements or _API_ that a module _exports_ for use by other modules.
Each module must then be _implemented_ such that it complies with its specification (_correctness_).
Additionally, this correctness must only depend on the specifications, not the implementations, of the modules whose program elements it uses (that is, whose program elements it _imports_).

The principle of modular programming is extremely general.
Specifically, its relevance is _not_ restricted to object-oriented programming or high-level languages like Java.
Nevertheless, this course covers modular software development in the context of OOP and particularly Java.
Both the OOP model and Java include principles (like encapsulation) and features (like static types) that facilitate modularity and defining interfaces.
Additionally, both OOP and the Java community traditionally attach great value to modularity and specification of interfaces.

The focus of this course will be on how to design and clearly define the syntax and semantics of module APIs.
For defining the syntax of APIs, we will make use of Java's support for this, particularly its strong static typing, and its support for encapsulation (the compiler and virtual machine (Java's execution environment) together enforce that a module is accessed only through its official API, and that the correct number and types of arguments are passed to each API call).
However, besides precisely defining the syntax of APIs, it is crucial to also precisely module APIs' _semantics_ (meaning), in terms of the behavior generated by API calls.
Therefore, in this course, we put a strong emphasis on how to write clear and comprehensive _documentation_ for APIs.

For the sake of clarity and precision, we will supplement informal documentation with formal specifications.
Such formal specifications specify properties of APIs in a way that can be given a precise meaning.
The additional formality reduces ambiguity and can facilitate testing and verification.
Although such formal specifications are not standard (even in large projects that attach great value to modularity), we believe it is useful to expose students to them, for two reasons.
First, formal specification encourages students to be fully precise, think about corner cases and reason rigorously about correctness.
Second, formal specifications also provide a stepping stone towards software verification tools that are an important topic in the authors' research.\footnote{Bart Jacobs is the lead author of the verification tool [VeriFast](https://github.com/verifast/verifast) and Dominique Devriese applies verification techniques to security applications.}
Because there is no widely accepted formalism, we use a minimal one designed specifically for this course.
